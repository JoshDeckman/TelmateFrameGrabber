/* Autogenerated with kurento-module-creator */

#include "TelmateFrameGrabberOpenCVImpl.hpp"
#include <KurentoException.hpp>

namespace pt = boost::posix_time;

namespace kurento {

TelmateFrameGrabberOpenCVImpl::TelmateFrameGrabberOpenCVImpl()
{

    this->thrLoop = true;
    this->frameQueue = new boost::lockfree::queue<VideoFrame *>(0);
    this->snapInterval = 1000;
    this->epName = "EP_NAME_UNINITIALIZED";
    this->storagePath = "/tmp";
    this->framesCounter = 0;

    this->thr = new boost::thread(boost::bind(&TelmateFrameGrabberOpenCVImpl::queueHandler, this));

    GST_DEBUG("TelmateFrameGrabberOpenCVImpl::TelmateFrameGrabberOpenCVImpl() called");
}


TelmateFrameGrabberOpenCVImpl::~TelmateFrameGrabberOpenCVImpl()
{

    this->thrLoop = false;
    this->thr->join();
    delete this->frameQueue;
    this->frameQueue = NULL;
    delete this->thr;
    this->thr = NULL;

    GST_DEBUG("TelmateFrameGrabberOpenCVImpl::~TelmateFrameGrabberOpenCVImpl() called");
}

/*
 * This function will be called with each new frame. mat variable
 * contains the current frame. You should insert your image processing code
 * here. Any changes in mat, will be sent through the Media Pipeline.
 */
void TelmateFrameGrabberOpenCVImpl::process(cv::Mat &mat)
{
    GST_DEBUG("ENDPOINT NAME: %s", this->epName.c_str());

        if ((this->getCurrentTimestampLong() - this->lastQueueTimeStamp) > this->snapInterval) {

            VideoFrame *ptrVf = new VideoFrame();
            ptrVf->mat = mat.clone();
            ptrVf->ts = this->getCurrentTimestampString();
            this->lastQueueTimeStamp = this->getCurrentTimestampLong();

            this->frameQueue->push(ptrVf);
            ++this->queueLength;
            ++this->framesCounter;
        }

}
/*
 * This function is executed inside the queueHandler thread as a main() function.
 * It pops a VideoFrame from the framequeue and saves it to disk.
 * a boost scoped_lock is implemented to ensure the queue is emptied to disk before
 * the destructor is executed. a 1 second sleep is implemented inside the while() loop
 * to ensure the cpu isn't exhausted while the queue is empty.
 */
void TelmateFrameGrabberOpenCVImpl::queueHandler()
{
    VideoFrame *ptrVf;
    cv::Mat image;
    std::vector<int> params;

    /* Set PNG parameters, compression etc. */
    params.push_back(CV_IMWRITE_PNG_COMPRESSION);
    params.push_back(9);

    boost::mutex::scoped_lock lock(workerThreadMutex);

    while(this->thrLoop) {

        if (!this->frameQueue->empty()) {

            empty_queue:
                this->frameQueue->pop(ptrVf);
                --this->queueLength;

                std::string filename = std::to_string(this->framesCounter) + "_" + ptrVf->ts + ".png";

                if(this->storagePathSubdir.size() == 0) {

                    this->storagePathSubdir = this->storagePath + "/frames_" + this->getCurrentTimestampString();
                    boost::filesystem::path dir(this->storagePathSubdir.c_str());

                    if(!boost::filesystem::is_directory(dir)) {
                        /* Directory does not exist, create it */
                        boost::filesystem::create_directories(dir);
                    }
                }

                std::string fullpath = this->storagePathSubdir  + "/" + filename;

                cv::imwrite(fullpath.c_str(),ptrVf->mat,params);
                ptrVf->mat.release();

                delete ptrVf;
                ptrVf = NULL;

        }
        else {
            boost::this_thread::sleep( boost::posix_time::seconds(1) );
        }
    }

    while(!this->frameQueue->empty()) {
        goto empty_queue;
        GST_DEBUG("Emptying frameQueue..");
    }

    lock.unlock();

}

std::string TelmateFrameGrabberOpenCVImpl::getCurrentTimestampString()
{
    struct timeval tp;
    long int ms;
    std::stringstream sstr_ts;

    gettimeofday(&tp, NULL);
    ms = tp.tv_sec * 1000 + tp.tv_usec / 1000;
    sstr_ts << ms;
    return sstr_ts.str();

}

long TelmateFrameGrabberOpenCVImpl::getCurrentTimestampLong()
{
    struct timeval tp;
    std::stringstream sstr_ts;

    gettimeofday(&tp, NULL);
    return (tp.tv_sec * 1000 + tp.tv_usec / 1000);

}


} /* kurento */
