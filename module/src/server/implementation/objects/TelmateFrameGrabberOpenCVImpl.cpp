/* Autogenerated with kurento-module-creator */

#include "TelmateFrameGrabberOpenCVImpl.hpp"
#include <KurentoException.hpp>

namespace pt = boost::posix_time;

namespace kurento {

TelmateFrameGrabberOpenCVImpl::TelmateFrameGrabberOpenCVImpl()
{

    this->thrLoop = true;
    this->frameQueue = new boost::lockfree::queue<VideoFrame *>(0);
    this->snapInterval = 1000;
    this->epName = "EP_NAME_UNINITIALIZED";
    this->storagePath = "/tmp";
    this->framesCounter = 0;
    this->outputFormat = FGFMT_JPEG;

    this->thr = new boost::thread(boost::bind(&TelmateFrameGrabberOpenCVImpl::queueHandler, this));

    GST_ERROR("TelmateFrameGrabberOpenCVImpl::TelmateFrameGrabberOpenCVImpl() called");
}


TelmateFrameGrabberOpenCVImpl::~TelmateFrameGrabberOpenCVImpl()
{

    this->thrLoop = false;
    this->thr->join();
    delete this->frameQueue;
    this->frameQueue = NULL;
    delete this->thr;
    this->thr = NULL;

    GST_ERROR("TelmateFrameGrabberOpenCVImpl::~TelmateFrameGrabberOpenCVImpl() called");
}

/*
 * This function will be called with each new frame. mat variable
 * contains the current frame. You should insert your image processing code
 * here. Any changes in mat, will be sent through the Media Pipeline.
 */
void TelmateFrameGrabberOpenCVImpl::process(cv::Mat &mat)
{

        if ((this->getCurrentTimestampLong() - this->lastQueueTimeStamp) > this->snapInterval) {

            VideoFrame *ptrVf = new VideoFrame();
            ptrVf->mat = mat.clone();
            ptrVf->ts = this->getCurrentTimestampString();
            this->lastQueueTimeStamp = this->getCurrentTimestampLong();

            this->frameQueue->push(ptrVf);
            ++this->queueLength;
            ++this->framesCounter;
        }

}
/*
 * This function is executed inside the queueHandler thread as a main() function.
 * It pops a VideoFrame from the framequeue and saves it to disk.
 * a boost scoped_lock is implemented to ensure the queue is emptied to disk before
 * the destructor is executed. a 1 second sleep is implemented inside the while() loop
 * to ensure the cpu isn't exhausted while the queue is empty.
 */
void TelmateFrameGrabberOpenCVImpl::queueHandler()
{
    VideoFrame *ptrVf;
    cv::Mat image;


    boost::mutex::scoped_lock lock(workerThreadMutex);

    while(this->thrLoop) {

        if (!this->frameQueue->empty()) {

            empty_queue:
                std::vector<int> params;
                std::string image_extension;

                this->frameQueue->pop(ptrVf);
                --this->queueLength;

                switch(this->outputFormat) {
                    case FGFMT_JPEG:
                        /* Set jpeg params */
                        params.push_back(CV_IMWRITE_JPEG_QUALITY);
                        params.push_back(FG_JPEG_QUALITY);
                        image_extension = ".jpeg";
                        break;
                    case FGFMT_PNG:
                        /* Set PNG parameters, compression etc. */
                        params.push_back(CV_IMWRITE_PNG_COMPRESSION);
                        params.push_back(FG_PNG_QUALITY);
                        image_extension = ".png";
                        break;
                    default:
                        /* Defaults to jpeg */
                        params.push_back(CV_IMWRITE_JPEG_QUALITY);
                        params.push_back(FG_JPEG_QUALITY);
                        image_extension = ".jpeg";
                        break;
                }

                std::string filename = std::to_string(this->framesCounter) + "_" + ptrVf->ts + image_extension;

                if(this->storagePathSubdir.size() == 0) {

                    this->storagePathSubdir = this->storagePath + "/frames_" + this->getCurrentTimestampString();
                }

                boost::filesystem::path dir(this->storagePathSubdir.c_str());
                boost::filesystem::create_directories(dir);
                GST_ERROR("boost::filesystem::create_directories(dir);");

                std::string fullpath = this->storagePathSubdir  + "/" + filename;


                try {
                    cv::imwrite(fullpath.c_str(),ptrVf->mat,params);
                }
                catch (...) {
                    throw KurentoException (NOT_IMPLEMENTED, "TelmateFrameGrabberOpenCVImpl::queueHandler() imgwrite() failed.\n");
                    GST_ERROR("TelmateFrameGrabberOpenCVImpl::queueHandler() imgwrite() failed.");
                }

                ptrVf->mat.release();

                delete ptrVf;
                ptrVf = NULL;

        }
        else {
            boost::this_thread::sleep( boost::posix_time::seconds(1) );
        }
    }

    while(!this->frameQueue->empty()) {
        goto empty_queue;
        GST_ERROR("Emptying frameQueue..");
    }

    lock.unlock();

}

std::string TelmateFrameGrabberOpenCVImpl::getCurrentTimestampString()
{
    struct timeval tp;
    long int ms;
    std::stringstream sstr_ts;

    gettimeofday(&tp, NULL);
    ms = tp.tv_sec * 1000 + tp.tv_usec / 1000;
    sstr_ts << ms;
    return sstr_ts.str();

}

long TelmateFrameGrabberOpenCVImpl::getCurrentTimestampLong()
{
    struct timeval tp;
    std::stringstream sstr_ts;

    gettimeofday(&tp, NULL);
    return (tp.tv_sec * 1000 + tp.tv_usec / 1000);

}


} /* kurento */
